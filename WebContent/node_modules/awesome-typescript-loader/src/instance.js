"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const _ = require("lodash");
const helpers_1 = require("./helpers");
const checker_1 = require("./checker");
const watch_mode_1 = require("./watch-mode");
let colors = require('colors/safe');
let pkg = require('../package.json');
let mkdirp = require('mkdirp');
function getRootCompiler(compiler) {
    if (compiler.parentCompilation) {
        return getRootCompiler(compiler.parentCompilation.compiler);
    }
    else {
        return compiler;
    }
}
exports.getRootCompiler = getRootCompiler;
function resolveInstance(compiler, instanceName) {
    if (!compiler._tsInstances) {
        compiler._tsInstances = {};
    }
    return compiler._tsInstances[instanceName];
}
const COMPILER_ERROR = colors.red(`\n\nTypescript compiler cannot be found, please add it to your package.json file:
    npm install --save-dev typescript
`);
const BABEL_ERROR = colors.red(`\n\nBabel compiler cannot be found, please add it to your package.json file:
    npm install --save-dev babel-core
`);
let id = 0;
function ensureInstance(webpack, query, options, instanceName, rootCompiler) {
    let exInstance = resolveInstance(rootCompiler, instanceName);
    if (exInstance) {
        return exInstance;
    }
    const watching = isWatching(rootCompiler);
    const context = process.cwd();
    let compilerInfo = setupTs(query.compiler);
    let { tsImpl } = compilerInfo;
    let { configFilePath, compilerConfig, loaderConfig } = readConfigFile(context, query, options, tsImpl);
    applyDefaults(configFilePath, compilerConfig, loaderConfig, context);
    if (!loaderConfig.silent) {
        const sync = watching === WatchMode.Enabled ? ' (in a forked process)' : '';
        console.log(`\n[${instanceName}] Using typescript@${compilerInfo.compilerVersion} from ${compilerInfo.compilerPath} and `
            + `"tsconfig.json" from ${configFilePath}${sync}.\n`);
    }
    let babelImpl = setupBabel(loaderConfig, context);
    let cacheIdentifier = setupCache(loaderConfig, tsImpl, webpack, babelImpl, context);
    let compiler = webpack._compiler;
    setupWatchRun(compiler, instanceName);
    setupAfterCompile(compiler, instanceName);
    const webpackOptions = _.pick(webpack._compiler.options, 'resolve');
    const checker = new checker_1.Checker(compilerInfo, loaderConfig, compilerConfig, webpackOptions, context, watching === WatchMode.Enabled);
    return rootCompiler._tsInstances[instanceName] = {
        id: ++id,
        babelImpl,
        compiledFiles: {},
        loaderConfig,
        configFilePath,
        compilerConfig,
        checker,
        cacheIdentifier,
        context
    };
}
exports.ensureInstance = ensureInstance;
function findTsImplPackage(inputPath) {
    let pkgDir = path.dirname(inputPath);
    if (fs.readdirSync(pkgDir).find((value) => value === 'package.json')) {
        return path.join(pkgDir, 'package.json');
    }
    else {
        return findTsImplPackage(pkgDir);
    }
}
function setupTs(compiler) {
    let compilerPath = compiler || 'typescript';
    let tsImpl;
    let tsImplPath;
    try {
        tsImplPath = require.resolve(compilerPath);
        tsImpl = require(tsImplPath);
    }
    catch (e) {
        console.error(e);
        console.error(COMPILER_ERROR);
        process.exit(1);
    }
    const pkgPath = findTsImplPackage(tsImplPath);
    const compilerVersion = require(pkgPath).version;
    let compilerInfo = {
        compilerPath,
        compilerVersion,
        tsImpl,
    };
    return compilerInfo;
}
exports.setupTs = setupTs;
function setupCache(loaderConfig, tsImpl, webpack, babelImpl, context) {
    let cacheIdentifier = null;
    if (loaderConfig.useCache) {
        if (!loaderConfig.cacheDirectory) {
            loaderConfig.cacheDirectory = path.join(context, '.awcache');
        }
        if (!fs.existsSync(loaderConfig.cacheDirectory)) {
            mkdirp.sync(loaderConfig.cacheDirectory);
        }
        cacheIdentifier = {
            'typescript': tsImpl.version,
            'awesome-typescript-loader': pkg.version,
            'awesome-typescript-loader-query': webpack.query,
            'babel-core': babelImpl
                ? babelImpl.version
                : null
        };
    }
}
function setupBabel(loaderConfig, context) {
    let babelImpl;
    if (loaderConfig.useBabel) {
        try {
            let babelPath = loaderConfig.babelCore || path.join(context, 'node_modules', 'babel-core');
            babelImpl = require(babelPath);
        }
        catch (e) {
            console.error(BABEL_ERROR);
            process.exit(1);
        }
    }
    return babelImpl;
}
function applyDefaults(configFilePath, compilerConfig, loaderConfig, context) {
    const def = {
        sourceMap: true,
        verbose: false,
        skipDefaultLibCheck: true,
        suppressOutputPathCheck: true
    };
    if (compilerConfig.options.outDir && compilerConfig.options.declaration) {
        def.declarationDir = compilerConfig.options.outDir;
    }
    _.defaults(compilerConfig.options, def);
    if (loaderConfig.transpileOnly) {
        compilerConfig.options.isolatedModules = true;
    }
    _.defaults(compilerConfig.options, {
        sourceRoot: compilerConfig.options.sourceMap ? context : undefined
    });
    _.defaults(loaderConfig, {
        sourceMap: true,
        verbose: false,
    });
    delete compilerConfig.options.outDir;
    delete compilerConfig.options.outFile;
    delete compilerConfig.options.out;
    delete compilerConfig.options.noEmit;
}
function absolutize(fileName, context) {
    if (path.isAbsolute(fileName)) {
        return fileName;
    }
    else {
        return path.join(context, fileName);
    }
}
function readConfigFile(context, query, options, tsImpl) {
    let configFilePath;
    if (query.configFileName && query.configFileName.match(/\.json$/)) {
        configFilePath = absolutize(query.configFileName, context);
    }
    else {
        configFilePath = tsImpl.findConfigFile(context, tsImpl.sys.fileExists);
    }
    let existingOptions = tsImpl.convertCompilerOptionsFromJson(query, context, 'atl.query');
    if (!configFilePath || query.configFileContent) {
        return {
            configFilePath: configFilePath || path.join(context, 'tsconfig.json'),
            compilerConfig: tsImpl.parseJsonConfigFileContent(query.configFileContent || {}, tsImpl.sys, context, _.extend({}, tsImpl.getDefaultCompilerOptions(), existingOptions.options), context),
            loaderConfig: query
        };
    }
    let jsonConfigFile = tsImpl.readConfigFile(configFilePath, tsImpl.sys.readFile);
    let compilerConfig = tsImpl.parseJsonConfigFileContent(jsonConfigFile.config, tsImpl.sys, path.dirname(configFilePath), existingOptions.options, configFilePath);
    return {
        configFilePath,
        compilerConfig,
        loaderConfig: _.defaults(query, jsonConfigFile.config.awesomeTypescriptLoaderOptions, options)
    };
}
exports.readConfigFile = readConfigFile;
let EXTENSIONS = /\.tsx?$|\.jsx?$/;
function setupWatchRun(compiler, instanceName) {
    compiler.plugin('watch-run', function (watching, callback) {
        const instance = resolveInstance(watching.compiler, instanceName);
        const checker = instance.checker;
        const watcher = watching.compiler.watchFileSystem.watcher
            || watching.compiler.watchFileSystem.wfs.watcher;
        const mtimes = watcher.mtimes || (watcher.getTimes && watcher.getTimes()) || {};
        const changedFiles = Object.keys(mtimes).map(helpers_1.toUnix);
        const updates = changedFiles
            .filter(file => EXTENSIONS.test(file))
            .map(changedFile => {
            if (fs.existsSync(changedFile)) {
                checker.updateFile(changedFile, fs.readFileSync(changedFile).toString(), true);
            }
            else {
                checker.removeFile(changedFile);
            }
        });
        Promise.all(updates)
            .then(() => callback())
            .catch(callback);
    });
}
var WatchMode;
(function (WatchMode) {
    WatchMode[WatchMode["Enabled"] = 0] = "Enabled";
    WatchMode[WatchMode["Disabled"] = 1] = "Disabled";
    WatchMode[WatchMode["Unknown"] = 2] = "Unknown";
})(WatchMode || (WatchMode = {}));
function isWatching(compiler) {
    const value = compiler && compiler[watch_mode_1.WatchModeSymbol];
    if (value === true) {
        return WatchMode.Enabled;
    }
    else if (value === false) {
        return WatchMode.Disabled;
    }
    else {
        return WatchMode.Unknown;
    }
}
function setupAfterCompile(compiler, instanceName, forkChecker = false) {
    compiler.plugin('after-compile', function (compilation, callback) {
        if (compilation.compiler.isChild()) {
            callback();
            return;
        }
        const watchMode = isWatching(compilation.compiler);
        const instance = resolveInstance(compilation.compiler, instanceName);
        const silent = instance.loaderConfig.silent;
        const asyncErrors = watchMode === WatchMode.Enabled && !silent;
        let emitError = (msg) => {
            if (compilation.bail) {
                console.error('Error in bail mode:', msg);
                process.exit(1);
            }
            if (asyncErrors) {
                console.log(msg, '\n');
            }
            else {
                compilation.errors.push(new Error(msg));
            }
        };
        instance.compiledFiles = {};
        const files = instance.checker.getFiles()
            .then(({ files }) => {
            Array.prototype.push.apply(compilation.fileDependencies, files.map(path.normalize));
        });
        const diag = instance.loaderConfig.transpileOnly
            ? Promise.resolve()
            : instance.checker.getDiagnostics()
                .then(diags => {
                diags.forEach(diag => emitError(diag.pretty));
            });
        files
            .then(() => {
            if (asyncErrors) {
                return;
            }
            else {
                return diag;
            }
        })
            .then(() => callback())
            .catch(callback);
    });
}
//# sourceMappingURL=instance.js.map