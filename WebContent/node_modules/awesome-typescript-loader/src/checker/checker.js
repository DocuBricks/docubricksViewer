"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const childProcess = require("child_process");
const path = require("path");
const send_1 = require("./send");
class Checker {
    constructor(compilerInfo, loaderConfig, compilerConfig, webpackOptions, context, fork = false) {
        this.seq = 0;
        this.pending = new Map();
        const execArgv = getExecArgv();
        const checker = fork
            ? childProcess.fork(path.join(__dirname, 'runtime.js'), [], { execArgv })
            : require('./runtime').run();
        this.sender = fork
            ? send_1.createQueuedSender(checker)
            : { send: checker.send };
        this.checker = checker;
        this.compilerInfo = compilerInfo;
        this.loaderConfig = loaderConfig;
        this.compilerConfig = compilerConfig;
        this.webpackOptions = webpackOptions;
        checker.on('error', (e) => {
            console.error('Typescript checker error:', e);
        });
        checker.on('message', (res) => {
            const { seq, success, payload } = res;
            if (seq && this.pending.has(seq)) {
                const resolver = this.pending.get(seq);
                if (success) {
                    resolver.resolve(payload);
                }
                else {
                    resolver.reject(payload);
                }
                this.pending.delete(seq);
            }
            else {
                console.warn('Unknown message: ', payload);
            }
        });
        this.req({
            type: 'Init',
            payload: {
                compilerInfo: _.omit(compilerInfo, 'tsImpl'),
                loaderConfig,
                compilerConfig,
                webpackOptions,
                context
            }
        });
    }
    req(message) {
        message.seq = ++this.seq;
        const promise = new Promise((resolve, reject) => {
            let resolver = {
                resolve, reject
            };
            this.pending.set(message.seq, resolver);
        });
        this.sender.send(message);
        return promise;
    }
    emitFile(fileName, text) {
        return this.req({
            type: 'EmitFile',
            payload: {
                fileName,
                text
            }
        });
    }
    updateFile(fileName, text, ifExist = false) {
        return this.req({
            type: 'UpdateFile',
            payload: {
                fileName,
                text,
                ifExist
            }
        });
    }
    removeFile(fileName) {
        return this.req({
            type: 'RemoveFile',
            payload: {
                fileName,
            }
        });
    }
    getDiagnostics() {
        return this.req({
            type: 'Diagnostics'
        });
    }
    getFiles() {
        return this.req({
            type: 'Files'
        });
    }
    kill() {
        this.checker.kill('SIGKILL');
    }
}
exports.Checker = Checker;
function getExecArgv() {
    let execArgv = [];
    for (let _i = 0, _a = process.execArgv; _i < _a.length; _i++) {
        let arg = _a[_i];
        let match = /^--(debug|inspect)(=(\d+))?$/.exec(arg);
        if (match) {
            let currentPort = match[3] !== undefined ? +match[3] : match[1] === "debug" ? 5858 : 9229;
            execArgv.push("--" + match[1] + "=" + (currentPort + 1));
            break;
        }
    }
    return execArgv;
}
//# sourceMappingURL=checker.js.map