"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const instance_1 = require("./instance");
const path = require("path");
const _ = require("lodash");
const ModulesInRootPlugin = require('enhanced-resolve/lib/ModulesInRootPlugin');
const createInnerCallback = require('enhanced-resolve/lib/createInnerCallback');
const getInnerRequest = require('enhanced-resolve/lib/getInnerRequest');
function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
class PathPlugin {
    constructor(config = {}) {
        this.source = 'described-resolve';
        this.target = 'resolve';
        this.ts = instance_1.setupTs(config.compiler).tsImpl;
        let context = config.context || process.cwd();
        let { configFilePath, compilerConfig } = instance_1.readConfigFile(context, config, {}, this.ts);
        this.options = compilerConfig.options;
        this.configFilePath = configFilePath;
        this.baseUrl = this.options.baseUrl;
        this.absoluteBaseUrl = path.resolve(path.dirname(this.configFilePath), this.baseUrl || '.');
        this.mappings = [];
        let paths = this.options.paths || {};
        Object.keys(paths).forEach(alias => {
            let onlyModule = alias.indexOf('*') === -1;
            let excapedAlias = escapeRegExp(alias);
            let targets = paths[alias];
            targets.forEach(target => {
                let aliasPattern;
                if (onlyModule) {
                    aliasPattern = new RegExp(`^${excapedAlias}$`);
                }
                else {
                    let withStarCapturing = excapedAlias.replace('\\*', '(.*)');
                    aliasPattern = new RegExp(`^${withStarCapturing}`);
                }
                this.mappings.push({
                    onlyModule,
                    alias,
                    aliasPattern,
                    target: target
                });
            });
        });
    }
    apply(resolver) {
        let { baseUrl, mappings } = this;
        if (baseUrl) {
            resolver.apply(new ModulesInRootPlugin("module", this.absoluteBaseUrl, "resolve"));
        }
        mappings.forEach(mapping => {
            resolver.plugin(this.source, this.createPlugin(resolver, mapping));
        });
    }
    createPlugin(resolver, mapping) {
        return (request, callback) => {
            let innerRequest = getInnerRequest(resolver, request);
            if (!innerRequest) {
                return callback();
            }
            let match = innerRequest.match(mapping.aliasPattern);
            if (!match) {
                return callback();
            }
            let newRequestStr = mapping.target;
            if (!mapping.onlyModule) {
                newRequestStr = newRequestStr.replace('*', match[1]);
            }
            if (newRequestStr[0] === '.') {
                newRequestStr = path.resolve(this.absoluteBaseUrl, newRequestStr);
            }
            let newRequest = _.extend({}, request, {
                request: newRequestStr
            });
            return resolver.doResolve(this.target, newRequest, "aliased with mapping '" + innerRequest + "': '" + mapping.alias + "' to '" + newRequestStr + "'", createInnerCallback(function (err, result) {
                if (arguments.length > 0) {
                    return callback(err, result);
                }
                callback(null, null);
            }, callback));
        };
    }
}
exports.PathPlugin = PathPlugin;
//# sourceMappingURL=paths-plugin.js.map