"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const _ = require("lodash");
const child = require("child_process");
const webpack = require("webpack");
const shelljs_1 = require("shelljs");
require('source-map-support').install();
const chai_1 = require("chai");
exports.expect = chai_1.expect;
const BPromise = require('bluebird');
const mkdirp = BPromise.promisify(require('mkdirp'));
const readFile = BPromise.promisify(fs.readFile);
const writeFile = BPromise.promisify(fs.writeFile);
exports.defaultOutputDir = path.join(process.cwd(), '.test');
exports.defaultFixturesDir = path.join(process.cwd(), 'fixtures');
const TEST_DIR = path.join(process.cwd(), '.test');
const SRC_DIR = './src';
const OUT_DIR = './out';
const WEBPACK = path.join(path.dirname(path.dirname(require.resolve('webpack'))), 'bin', 'webpack.js');
mkdirp.sync(TEST_DIR);
const LOADER = path.join(process.cwd(), 'index.js');
function entry(file) {
    return config => {
        config.entry.index = path.join(process.cwd(), SRC_DIR, file);
    };
}
exports.entry = entry;
function query(q) {
    return config => {
        _.merge(config.module.loaders.find(loader => loader.loader === LOADER).query, q);
    };
}
exports.query = query;
function webpackConfig(...enchance) {
    const config = {
        entry: { index: path.join(process.cwd(), SRC_DIR, 'index.ts') },
        output: {
            path: path.join(process.cwd(), OUT_DIR),
            filename: '[name].js'
        },
        resolve: {
            extensions: ['.ts', '.tsx', '.js', '.jsx']
        },
        module: {
            loaders: [
                {
                    test: /\.(tsx?|jsx?)/,
                    loader: LOADER,
                    include: [path.join(process.cwd(), SRC_DIR)],
                    query: {
                        silent: true
                    }
                }
            ]
        }
    };
    enchance.forEach(e => e(config));
    return config;
}
exports.webpackConfig = webpackConfig;
class Exec {
    constructor() {
        this.watchers = [];
        this._strictOutput = false;
    }
    close() {
        this.process.kill();
    }
    strictOutput() {
        this._strictOutput = true;
    }
    invoke({ stdout, stderr }) {
        this.watchers = this.watchers.filter(watcher => {
            const output = {
                type: stdout ? 'stdout' : 'stderr',
                data: stdout || stderr
            };
            const index = watcher.matchers.findIndex(m => m(output));
            if (this._strictOutput && index === -1) {
                watcher.reject(new Error(`Unexpected ${output.type}:\n${output.data}`));
                return false;
            }
            watcher.matchers.splice(index, 1);
            if (watcher.matchers.length === 0) {
                watcher.resolve();
                return false;
            }
            else {
                return true;
            }
        });
    }
    wait(...matchers) {
        return new Promise((resolve, reject) => {
            const watcher = {
                resolve,
                reject,
                matchers,
            };
            this.watchers.push(watcher);
        });
    }
    alive() {
        return new Promise((resolve, reject) => {
            if (this.exitCode != null) {
                resolve(this.exitCode);
            }
            else {
                this.process.on('exit', resolve);
            }
        });
    }
}
exports.Exec = Exec;
function streamTest(stream = 'stdout', test) {
    let matcher;
    if (typeof test === 'string') {
        matcher = (o) => o.indexOf(test) !== -1;
    }
    else if (Array.isArray(test)) {
        matcher = (o) => test.every(test => {
            if (typeof test === 'string') {
                return o.indexOf(test) !== -1;
            }
            else {
                const [flag, str] = test;
                if (flag) {
                    return o.indexOf(str) !== -1;
                }
                else {
                    return o.indexOf(str) === -1;
                }
            }
        });
    }
    else if (test instanceof RegExp) {
        matcher => (o) => test.test(o);
    }
    else {
        matcher = test;
    }
    return (o) => (o.type === stream) && matcher(o.data);
}
exports.streamTest = streamTest;
exports.stdout = (test) => streamTest('stdout', test);
exports.stderr = (test) => streamTest('stderr', test);
function execWebpack(args) {
    return execNode(WEBPACK, args);
}
exports.execWebpack = execWebpack;
function execNode(command, args = []) {
    return exec('node', [command].concat(args));
}
exports.execNode = execNode;
function exec(command, args) {
    const p = shelljs_1.exec(`${command} ${args.join(' ')}`, {
        async: true
    });
    const waiter = new Exec();
    p.stdout.on('data', (data) => {
        console.log(data.toString());
        waiter.invoke({ stdout: data.toString(), stderr: null });
    });
    p.stderr.on('data', (data) => {
        console.error(data.toString());
        waiter.invoke({ stdout: null, stderr: data.toString() });
    });
    process.on('beforeExit', () => {
        p.kill();
    });
    process.on('exit', (code) => {
        waiter.exitCode = code;
        p.kill();
    });
    waiter.process = p;
    return waiter;
}
exports.exec = exec;
function expectErrors(stats, count, errors = []) {
    stats.compilation.errors.every(err => {
        const str = err.toString();
        chai_1.expect(errors.some(e => str.indexOf(e) !== -1), 'Error is not covered: \n' + str).true;
    });
    chai_1.expect(stats.compilation.errors.length).eq(count);
}
exports.expectErrors = expectErrors;
function expectWarnings(stats, count, warnings = []) {
    stats.compilation.warnings.every(warn => {
        const str = warn.toString();
        chai_1.expect(warnings.some(e => str.indexOf(e) !== -1), 'Warning is not covered: \n' + str).true;
    });
    chai_1.expect(stats.compilation.warnings.length).eq(count);
}
exports.expectWarnings = expectWarnings;
function tsconfig(compilerOptions, config, fileName = 'tsconfig.json') {
    const res = _.merge({
        compilerOptions: _.merge({
            target: 'es6',
            moduleResolution: 'node',
            typeRoots: [
                './node_modules/@types'
            ]
        }, compilerOptions)
    }, config);
    return file(fileName, json(res));
}
exports.tsconfig = tsconfig;
function install(...name) {
    return child.execSync(`yarn add ${name.join(' ')}`);
}
exports.install = install;
function json(obj) {
    return JSON.stringify(obj, null, 4);
}
exports.json = json;
function checkOutput(fileName, fragment) {
    const source = readOutput(fileName);
    if (!source) {
        process.exit();
    }
    chai_1.expect(source.replace(/\s/g, '')).include(fragment.replace(/\s/g, ''));
}
exports.checkOutput = checkOutput;
function readOutput(fileName) {
    return fs.readFileSync(path.join(OUT_DIR, fileName || 'index.js')).toString();
}
exports.readOutput = readOutput;
function touchFile(fileName) {
    return readFile(fileName)
        .then(buf => buf.toString())
        .then(source => writeFile(fileName, source));
}
exports.touchFile = touchFile;
function compile(config) {
    return new Promise((resolve, reject) => {
        const compiler = webpack(config);
        compiler.run((err, stats) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(stats);
            }
        });
    });
}
exports.compile = compile;
function spec(name, cb, disable = false) {
    const runner = function (done) {
        const temp = path.join(TEST_DIR, path.basename(name).replace('.', '') + '-' +
            (new Date()).toTimeString()
                .replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1")
                .replace(/:/g, "-"));
        mkdirp.sync(temp);
        let cwd = process.cwd();
        process.chdir(temp);
        pkg();
        const env = {
            TEST_DIR,
            OUT_DIR,
            SRC_DIR,
            LOADER,
            WEBPACK
        };
        const promise = cb.call(this, env, done);
        return promise
            .then(a => {
            process.chdir(cwd);
            return a;
        })
            .catch(e => {
            process.chdir(cwd);
            throw e;
        });
    };
    const asyncRunner = cb.length === 2
        ? function (done) { runner.call(this, done).catch(done); return; }
        : function () { return runner.call(this); };
    if (disable) {
        xit(name, asyncRunner);
    }
    else {
        it(name, asyncRunner);
    }
}
exports.spec = spec;
function xspec(name, cb) {
    return spec(name, cb, true);
}
exports.xspec = xspec;
function watch(config, cb) {
    let compiler = webpack(config);
    let watch = new Watch();
    let webpackWatcher = compiler.watch({}, (err, stats) => {
        watch.invoke(err, stats);
        if (cb) {
            cb(err, stats);
        }
    });
    watch.close = webpackWatcher.close;
    return watch;
}
exports.watch = watch;
class Watch {
    constructor() {
        this.resolves = [];
    }
    invoke(err, stats) {
        this.resolves.forEach(({ resolve, reject }) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(stats);
            }
        });
        this.resolves = [];
    }
    wait() {
        return new Promise((resolve, reject) => {
            this.resolves.push({ resolve, reject });
        });
    }
}
exports.Watch = Watch;
function pkg() {
    file('package.json', `
        {
            "name": "test",
            "license": "MIT"
        }
    `);
}
exports.pkg = pkg;
function src(fileName, text) {
    return new Fixture(path.join(SRC_DIR, fileName), text);
}
exports.src = src;
function file(fileName, text) {
    return new Fixture(fileName, text);
}
exports.file = file;
class Fixture {
    constructor(fileName, text) {
        this.text = text;
        this.fileName = fileName;
        mkdirp.sync(path.dirname(this.fileName));
        fs.writeFileSync(this.fileName, text);
    }
    path() {
        return this.fileName;
    }
    toString() {
        return this.path();
    }
    touch() {
        touchFile(this.fileName);
    }
    update(updater) {
        let newText = updater(this.text);
        this.text = newText;
        fs.writeFileSync(this.fileName, newText);
    }
    remove() {
        fs.unlinkSync(this.fileName);
    }
}
exports.Fixture = Fixture;
//# sourceMappingURL=utils.js.map